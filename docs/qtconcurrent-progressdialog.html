<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- progressdialog.qdoc -->
  <title>Cascades : Progress Dialog Example</title>
  <link rel="stylesheet" type="text/css" href="style/offline.css" />
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="content"> 
    <a href="index.html" class="qtref"><span>Qt with Cascades UI Examples Documentation</span></a>
  </div>
  <div class="breadcrumb toolblock">
    <ul>
      <li class="first"><a href="index.html">Home</a></li>
      <!--  Breadcrumbs go here -->
    </ul>
  </div>
</div>
<div class="content mainContent">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#description">Description</a></li>
<li class="level1"><a href="#overview">Overview</a></li>
<li class="level1"><a href="#the-ui">The UI</a></li>
<li class="level1"><a href="#progressdialog">ProgressDialog</a></li>
</ul>
</div>
<h1 class="title">Progress Dialog Example</h1>
<span class="subtitle"></span>
<!-- $$$qtconcurrent/progressdialog-description -->
<div class="descr"> <a name="details"></a>
<p>Files:</p>
<ul>
<li><a href="qtconcurrent-progressdialog-assets-main-qml.html">qtconcurrent/progressdialog/assets/main.qml</a></li>
<li><a href="qtconcurrent-progressdialog-src-progressdialog-cpp.html">qtconcurrent/progressdialog/src/ProgressDialog.cpp</a></li>
<li><a href="qtconcurrent-progressdialog-src-progressdialog-hpp.html">qtconcurrent/progressdialog/src/ProgressDialog.hpp</a></li>
<li><a href="qtconcurrent-progressdialog-src-main-cpp.html">qtconcurrent/progressdialog/src/main.cpp</a></li>
<li><a href="qtconcurrent-progressdialog-progressdialog-pro.html">qtconcurrent/progressdialog/progressdialog.pro</a></li>
</ul>
<a name="description"></a>
<h2>Description</h2>
<p>The QtConcurrent Progress Dialog example shows how to use the QFutureWatcher class to monitor the progress of a long-running operation.</p>
<p class="centerAlign"><img src="images/progressdialog-example.png" alt="" /></p><a name="overview"></a>
<h2>Overview</h2>
<p>In this example we'll learn how to use the QFuture class of the QtConcurrent module to execute a long lasting operation in a separated thread and how to monitor the progress and state with the QFutureWatcher class.</p>
<a name="the-ui"></a>
<h2>The UI</h2>
<p>The UI of this sample application consists of two buttons, one to start the operation and one to cancel it. The progress of the operation is visualized by a progress bar. Above the two buttons is a label that shows the number of CPU cores that are used for the calculation.</p>
<p>The business logic of the application is encapsulated in the class ProgressDialog, which is exported to the UI as '<a href="#progressdialog">_progressDialog</a>'.</p>
<pre class="qml">                <span class="type">Label</span> {
                    <span class="name">horizontalAlignment</span>: <span class="name">HorizontalAlignment</span>.<span class="name">Center</span>

                    <span class="name">text</span>: <span class="name">qsTr</span>(<span class="string">&quot;Run the computation on %1 cores&quot;</span>).<span class="name">arg</span>(<span class="name">_progressDialog</span>.<span class="name">numberOfCores</span>)
                    <span class="type">textStyle</span> {
                        <span class="name">color</span>: <span class="name">Color</span>.<span class="name">White</span>
                        <span class="name">base</span>: <span class="name">SystemDefaults</span>.<span class="name">TextStyles</span>.<span class="name">TitleText</span>
                    }
                }</pre>
<p>The text of the label contains a placeholder, which gets substituted with the number of cores as reported by the ProgressDialog object.</p>
<pre class="qml">                    <span class="type">Button</span> {
                        <span class="name">text</span>: <span class="name">qsTr</span> (<span class="string">&quot;Start&quot;</span>)
                        <span class="name">enabled</span>: !<span class="name">_progressDialog</span>.<span class="name">active</span>
                        <span class="name">onClicked</span>: <span class="name">_progressDialog</span>.<span class="name">startComputation</span>()
                    }

                    <span class="type">Button</span> {
                        <span class="name">text</span>: <span class="name">qsTr</span> (<span class="string">&quot;Cancel&quot;</span>)
                        <span class="name">enabled</span>: <span class="name">_progressDialog</span>.<span class="name">active</span>
                        <span class="name">onClicked</span>: <span class="name">_progressDialog</span>.<span class="name">cancelComputation</span>()
                    }</pre>
<p>When the user clicks the 'Start' or 'Cancel' button, the startComputation() and cancelComputation() slots of the ProgressDialog object are invoked. Additionally the state of the buttons changes depending on whether a calculation is running or not.</p>
<pre class="qml">                <span class="type">ProgressIndicator</span> {
                    <span class="name">horizontalAlignment</span>: <span class="name">HorizontalAlignment</span>.<span class="name">Center</span>
                    <span class="name">topMargin</span>: <span class="number">40</span>

                    <span class="comment">// Show the progress bar only when computation is running</span>
                    <span class="name">opacity</span>: <span class="name">_progressDialog</span>.<span class="name">active</span> ? <span class="number">1.0</span> : <span class="number">0.0</span>

                    <span class="name">fromValue</span>: <span class="name">_progressDialog</span>.<span class="name">progressMinimum</span>
                    <span class="name">toValue</span>: <span class="name">_progressDialog</span>.<span class="name">progressMaximum</span>
                    <span class="name">value</span>: <span class="name">_progressDialog</span>.<span class="name">progressValue</span>
                }</pre>
<p>The progress properties of the progress bar (provided by Cascades' ProgressIndicator class) are bound against the progress properties of the ProgressDialog app object, so that they get updated automatically. The progress bar is only visible while the calculation is running.</p>
<a name="progressdialog"></a>
<h2>ProgressDialog</h2>
<p>The ProgressDialog is the central class in this sample application that contains all the business logic. It provides the two slots to start and cancel the calculation and properties that reflect the state and progress of the calculation. ProgressDialog contains a QFutureWatcher as member variable, which is used to monitor the progress and state of a QFuture instance. For this the signals of the future watcher are connected against private slots inside the constructor of ProgressDialog.</p>
<pre class="cpp">    ProgressDialog<span class="operator">::</span>ProgressDialog()
        : m_progressMinimum(<span class="number">0</span>)
        <span class="operator">,</span> m_progressMaximum(<span class="number">0</span>)
        <span class="operator">,</span> m_progressValue(<span class="number">0</span>)
    {
        <span class="comment">// Forward state change signals from the watcher to our 'active' property</span>
        connect(<span class="operator">&amp;</span>m_futureWatcher<span class="operator">,</span> SIGNAL(started())<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SIGNAL(activeChanged()));
        connect(<span class="operator">&amp;</span>m_futureWatcher<span class="operator">,</span> SIGNAL(finished())<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SIGNAL(activeChanged()));

        <span class="comment">// Monitor progress changes of the future to update our own properties</span>
        connect(<span class="operator">&amp;</span>m_futureWatcher<span class="operator">,</span> SIGNAL(progressRangeChanged(<span class="type">int</span><span class="operator">,</span> <span class="type">int</span>))<span class="operator">,</span>
                <span class="keyword">this</span><span class="operator">,</span> SLOT(progressRangeChanged(<span class="type">int</span><span class="operator">,</span> <span class="type">int</span>)));
        connect(<span class="operator">&amp;</span>m_futureWatcher<span class="operator">,</span> SIGNAL(progressValueChanged(<span class="type">int</span>))<span class="operator">,</span>
                <span class="keyword">this</span><span class="operator">,</span> SLOT(progressValueChanged(<span class="type">int</span>)));
        connect(<span class="operator">&amp;</span>m_futureWatcher<span class="operator">,</span> SIGNAL(finished())<span class="operator">,</span>
                <span class="keyword">this</span><span class="operator">,</span> SLOT(calculationFinished()));
    }</pre>
<p>When the user clicks the 'Start' button in the UI, the startCalculation() slot is invoked</p>
<pre class="cpp">    <span class="type">void</span> ProgressDialog<span class="operator">::</span>startComputation()
    {
        <span class="comment">// Prepare the vector</span>
        <span class="type">QVector</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vector;
        <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">40</span>; <span class="operator">+</span><span class="operator">+</span>i)
            vector<span class="operator">.</span>append(i);

        <span class="comment">/**
         * Start the computation.
         * The returned Future object is just a handle to the running operation, which
         * is executed asynchronously in separated threads.
         */</span>
        <span class="keyword">const</span> <span class="type">QFuture</span><span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="type">QtConcurrent</span><span class="operator">::</span>map(vector<span class="operator">,</span> spin);

        <span class="comment">// Let the future watcher monitor the progress of this Future</span>
        m_futureWatcher<span class="operator">.</span>setFuture(future);
    }</pre>
<p>Inside this slot, a vector is filled with some dummy value that act as input values for the calculation. Then the actual calculation is started by calling QtConcurrent::map(). This method from the QtConcurrent module takes a container and a function as parameters and executes the function once for each entry in the container in a separated thread. The function we use in this example just burns some CPU cycles:</p>
<pre class="cpp">    <span class="type">void</span> spin(<span class="type">int</span> <span class="operator">&amp;</span>iteration)
    {
        Q_UNUSED(iteration)

        <span class="keyword">const</span> <span class="type">int</span> work <span class="operator">=</span> <span class="number">1000</span> <span class="operator">*</span> <span class="number">1000</span> <span class="operator">*</span> <span class="number">40</span>;
        <span class="keyword">volatile</span> <span class="type">int</span> v <span class="operator">=</span> <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="type">int</span> j <span class="operator">=</span> <span class="number">0</span>; j <span class="operator">&lt;</span> work; <span class="operator">+</span><span class="operator">+</span>j)
            <span class="operator">+</span><span class="operator">+</span>v;
    }</pre>
<p>However the call to QtConcurrent::map() does not block until the calculation has finished but returns a QFuture object instead, which acts as a handle to monitor the progress and state of the calculation.</p>
<p>We set the returned future on the future watcher member variable and now the future watcher will emit the appropriated signals as soon as the future changes its progress or state.</p>
<p>When the user wants to cancel the calculation and clicks on the 'Cancel' button, then the cancelCalculation() slot is invoked, which calls cancel() on the QFutureWatcher object. This will cause the running calculation (and the used threads) to terminate.</p>
<pre class="cpp">    <span class="type">void</span> ProgressDialog<span class="operator">::</span>cancelComputation()
    {
        <span class="comment">// Stop the computation</span>
        m_futureWatcher<span class="operator">.</span>cancel();
    }</pre>
<p>Internally the QtConcurrent module uses the QThreadPool class for distributing the calculation over multiple threads. The thread pool uses as many threads in parallel as returned by QThread::idealThreadCount(), which by default is the number of cores of the device the application is running on. The 'numberOfCores' property uses the same value:</p>
<pre class="cpp">    <span class="type">int</span> ProgressDialog<span class="operator">::</span>numberOfCores() <span class="keyword">const</span>
    {
        <span class="comment">/**
         * The QtConcurrent framework uses QThreadPool::globalInstance()
         * for computation and that one uses as many thread contexts as
         * returned by QThread::idelThreadCount().
         */</span>
        <span class="keyword">return</span> <span class="type">QThread</span><span class="operator">::</span>idealThreadCount();
    }</pre>
</div>
<!-- @@@qtconcurrent/progressdialog -->
  <div class="ft">
    <span></span>
  </div>
</div> 
<div class="footer">
  <p>
     Portions Copyright 2012 Research In Motion Limited.
     <acronym title="Copyright">&copy;</acronym> 2008-2011 Nokia Corporation and/or its
     subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
     in Finland and/or other countries worldwide.</p>
  <p>
     All other trademarks are property of their respective owners. <a title="Privacy Policy"
     href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
  <br />
  <p>
    Licensees holding valid Qt Commercial licenses may use this document in accordance with the    Qt Commercial License Agreement provided with the Software or, alternatively, in accordance    with the terms contained in a written agreement between you and Nokia.</p>
  <p>
    Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
    Free Documentation License version 1.3</a>
    as published by the Free Software Foundation.</p>
</div>
</body>
</html>
